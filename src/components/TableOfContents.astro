---
export interface Heading {
	depth: number;
	slug: string;
	text: string;
}

export interface Props {
	headings: Heading[];
	class?: string;
}

const { headings, class: className } = Astro.props;

// Create hierarchy
function buildHeadingTree(headings: Heading[]) {
	const tree: (Heading & { children: Heading[] })[] = [];
	const stack: (Heading & { children: Heading[] })[] = [];

	headings.forEach((heading) => {
		const node = { ...heading, children: [] };

		// Find correct parent on depth basis
		while (stack.length > 0 && stack[stack.length - 1].depth >= heading.depth) {
			stack.pop();
		}

		if (stack.length === 0) {
			tree.push(node);
		} else {
			stack[stack.length - 1].children.push(node);
		}

		stack.push(node);
	});

	return tree;
}

const headingTree = buildHeadingTree(headings);
---

<nav class={`w-100 ${className || ''}`}>
	<div class="toc-container overflow-y-auto">
		<h3 class="text-sm font-semibold text-accent mb-4 uppercase tracking-wide">Contents</h3>
		{
			headingTree.length > 0 && (
				<ul class="space-y-1 text-sm">
					{headingTree.map((heading) => (
						<li>
							<a
								href={`#${heading.slug}`}
								class="block py-1 transition-colors duration-200 toc-link"
								data-depth={heading.depth}
							>
								{heading.text}
							</a>
							{heading.children.length > 0 && (
								<ul class="ml-4 mt-1 space-y-1 pl-3">
									{heading.children.map((child) => (
										<li>
											<a
												href={`#${child.slug}`}
												class="block py-1 transition-colors duration-200 toc-link text-xs"
												data-depth={child.depth}
											>
												{child.text}
											</a>
											{child.children.length > 0 && (
												<ul class="ml-3 mt-1 space-y-1">
													{child.children.map((grandchild) => (
														<li>
															<a
																href={`#${grandchild.slug}`}
																class="block py-1 transition-colors duration-200 toc-link text-xs"
																data-depth={grandchild.depth}
															>
																{grandchild.text}
															</a>
														</li>
													))}
												</ul>
											)}
										</li>
									))}
								</ul>
							)}
						</li>
					))}
				</ul>
			)
		}
	</div>
</nav>

<script>
	// To highlight current section
	document.addEventListener('DOMContentLoaded', () => {
		const observer = new IntersectionObserver(
			(entries) => {
				entries.forEach((entry) => {
					const id = entry.target.getAttribute('id');
					const tocLink = document.querySelector(`a[href="#${id}"]`);

					if (entry.isIntersecting) {
						// Remove active style from all links
						document.querySelectorAll('.toc-link').forEach((link) => {
							link.classList.remove('text-accent', 'font-medium');
							// link.classList.add();
						});

						// Add active style to current link
						if (tocLink) {
							// tocLink.classList.remove();
							tocLink.classList.add('text-accent', 'font-medium');
						}
					}
				});
			},
			{
				rootMargin: '-20% 0px -70% 0px',
				threshold: 0.1,
			}
		);

		// Observe all headings
		document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading) => {
			observer.observe(heading);
		});

		// Smooth scroll
		document.querySelectorAll('.toc-link').forEach((link) => {
			link.addEventListener('click', (e) => {
				e.preventDefault();
				const href = link.getAttribute('href');
				if (href) {
					const target = document.querySelector(href);
					if (target) {
						target.scrollIntoView({
							behavior: 'smooth',
							block: 'start',
						});
					}
				}
			});
		});
	});
</script>

<style>
	.toc-container {
		max-height: calc(100vh - 6rem);
	}

	/* Sidebar custom scrollbar */
	.toc-container::-webkit-scrollbar {
		width: 4px;
	}

	.toc-container::-webkit-scrollbar-track {
		background: transparent;
	}

	.toc-container::-webkit-scrollbar-thumb {
		background: var(--accent-color);
		border-radius: 2px;
	}
</style>
